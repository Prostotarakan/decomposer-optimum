function [D,an,an_] = Itable(A)
%% на входе
% A - матрица, описывающая двухвходовые блоки
% A(i,:)=[n n1 i1 n0 i0 a0 a1 a2 a3]
% n - номер блока
% n1, n0 - номера блоков старшего и млашего входов (входные переменные х1, х2, х4, ... отмечаются как -1 -2 -4...)
% i1, i0 - инверсность входов. 1 - неинверт. 0 - инверт
% a0 a1 a2 a3 - комбинация логической функции двухвходового блока
% Возможная часть f - уже существующие последовательности
%% на выходе:
% D - выходная матрица значений блоков с их выходными последовательностями
% an - последовательность блоков в порядке ярусов
% an_ - соответствующие ярусы
% Возвращает саму матрицу и разложение блоков на уровни
%%
D=A;
% D формируется как [D0; A D1];
% D0 - описание входных переменных
% D1 - выходные последовательности блоков
an=[]; % блоки в порядке обхода
an_=[]; % их соответствующие ярусы
%% Создание входных переменных
k_vh=abs(min([ min(D(:,2)) min(D(:,4))])); % поиск входной переменной с самым большим весом
k=1; 
D0=[];
while k<=k_vh % описание всех входных переменных от х1 до хk_vh
    x=[zeros(1,k_vh/k) ones(1,k_vh/k)]; %формирование повторяющейся части последовательности
    D0=[D0; -k_vh/k 0 0 0 0  0 0 0 0 repmat(x,1,k)]; % формирование строки матрицы 
    an=[an -k_vh/k]; % запись входных переменных в список блоков
    an_=[an_ 0]; % все входные переменнын расположены на нулевом ярусе
    k=k*2;
end

%% Создание матрицы
D=D(find(D(:,1)>0),:); % исключение уже описанных в D входных переменных
D=D(:,1:9); % очищение уже существующих выходных последовательностей
[s,h]=size(D); % размер изначальной матрицы D 
D1=zeros(s,k_vh*2); % заполнение выходных последовательностей блоков нулями

D=[D0; D D1]; % объединение в единую матрицу
[s,h]=size(D); % размер новой матрицы
%% Заполнение выходных последовательностей 
ani=length(an); 
i=ani+1;
% вычисление выходных последовательностей до тех пор, пока все блоки не описаны в an
while length(an)~=s  
    hi=find(an==D(i,2)); % есть ли входы у блока, уже описаные в an
    lo=find(an==D(i,4));
    if (hi) % если оба входных блока уже описаны, то можно описать этот блок
        if (lo)
            if (sum(D(i,10:h))==0) % проверка, что еще не описывали этот блок
                
                an=[an D(i,1)]; % добавляем его в последовательность блоков
                an_=[an_ max(an_(hi),an_(lo))+1]; % его ярус на один больше макстмального из ярусов входных блоков
                
                j=D(find(D(:,1)==D(i,2)),:); % старший блок и его последовательность
                if D(i,3)==0 % проверка старшего блока на инверсность
                    j=Inve(j);
                end   
                k=D(find(D(:,1)==D(i,4)),:); % младший блок и его последовательность
                if D(i,5)==0 % проверка младшего блока на инверсность
                    k=Inve(k);
                end
                
                % определение соответствующего выхода при подаче на вход пар чисел
                for d=10:h 
                    if j(d)==0
                        if k(d)==0
                            D(i,d)=D(i,6); %% комбинация 00 - a0
                        else
                            D(i,d)=D(i,7); %% комбинация 01 - a1
                        end
                    else
                        if k(d)==0
                            D(i,d)=D(i,8); %% комбинация 10 - a2
                        else
                            D(i,d)=D(i,9); %% комбинация 11 - a3
                        end
                    end
                end 
            end
        end
    end
    i=i+1; % изучение следующего блока
    if i>s
        i=ani+1; % снова рассматрение блоков матрицы A ( смещение на количество входных переменных)
    end
   
end
end

