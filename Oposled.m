function G = Oposled(D,A)
%% на входе
% D - вся матрица
% D(i,:)=[n n1 i1 n0 i0 a0 a1 a2 a3 f0_N]
% n - номер блока
% n1, n0 - номера блоков старшего и млашего входов (входные переменные х1, х2, х4, ... отмечаются как -1 -2 -4...)
% i1, i0 - инверсность входов. 1 - неинверт. 0 - инверт
% a0 a1 a2 a3 - комбинация логической функции двухвходового блока
% f0_N - выходная послеовательность
% A - номер последнего блока
%% на выходе
% G - сокращенная матрица
H1=[1]; H=[];G=[];
while length(H1)~=length(H) %может быть несколько раз, если удалена сложная цепочка
H1=H;
H=[unique([D(:,2);D(:,4)]); A]; % определение уникальных входных блоков и данного последнего блока
H(find(H==0))=[]; % удаление " входных блоков" у входных переменных
G=[]; 
for i=1:length(H)
    G=[G;D(find(D(:,1)==H(i)),:)]; %запись в матрицу G всех имеющихся в Н номеров блоков
end
D=G;
end
end

