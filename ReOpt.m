function D=ReOpt( D, An, an, an_, h_l)
%% Функция поиска возможной оптимизации
%% на входе
% D - вся матрица
% D(i,:)=[n n1 i1 n0 i0 a0 a1 a2 a3 f0_N]
% n - номер блока
% n1, n0 - номера блоков старшего и млашего входов (входные переменные х1, х2, х4, ... отмечаются как -1 -2 -4...)
% i1, i0 - инверсность входов. 1 - неинверт. 0 - инверт
% a0 a1 a2 a3 - комбинация логической функции двухвходового блока
% f0_N - выходная послеовательность
% An - рассматриваемый блок(строка из D)
% an - последовательность блоков в порядке ярусов
% an_ - ярусы последовательности блоков
% h_l - уровень фиксации (1 - старший, 0 - младший)
%% на выходе
% D со звездочками (звездочки = '-1')
%%
[s h]=size(D); % размер матрицы
 if (An(2)>0 || An(4)>0) % выход из рекурсии если дошел до 1 уровня

    if h_l==1  % старший вход фиксирован
        Fi=D(find(D(:,1)==An(2)),:);  %Fi - старший вход
        if An(3)==0
            Fi=Inve(Fi); % его инверсия,если i1 = 0
        end
        NFi=D(find(D(:,1)==An(4)),:);  %NFi - младший вход
        if An(5)==0
            NFi=Inve(NFi); % его инверсия,если i0 = 0
        end
        
        g=find(An(10:25)<0); % замена на * NFi там, где An уже * 
        if g
            NFi(g+9)=-1; % * = '-1'
        end
        
        for d=10:h % замена на * тех NFi, где только Fi влияет на выход
            if (Fi(d)==0) && An(6)==An(7) && NFi(d)~=-1 % если a0=a1 при Fi=0
                NFi(d)=-1;
            elseif (Fi(d)==1) && An(8)==An(9) && NFi(d)~=-1 % если a2=a3 при Fi=1
                NFi(d)=-1;  
            end
        end
        
    else  % нижний вход фиксирован
        Fi=D(find(D(:,1)==An(4)),:); %Fi - младший вход 
        if An(5)==0
            Fi=Inve(Fi); % его инверсия,если i0 = 0
        end
        NFi=D(find(D(:,1)==An(2)),:);  %NFi - старший вход
        if An(3)==0
            NFi=Inve(NFi); % его инверсия,если i1 = 0
        end
        g=find(An(10:h)<0); % замена на * NFi там, где An уже * 
        if g
            NFi(g)=-1; % * = '-1'
        end
    
        for d=10:h % замена на * тех NFi, где только Fi влияет на выход
            if (Fi(d)==0) && An(6)==An(8) && NFi(d)~=-1 % если a0=a2 при Fi=0
                NFi(d)=-1;
            elseif (Fi(d)==1) && An(7)==An(9) && NFi(d)~=-1 % если a1=a3 при Fi=1
                NFi(d)=-1;  
            end
        end
    end
%% после определения NFi вставляем ее на свое место в DAn 
    i=find(D(:,1)==NFi(1));
    DAn=D;
    if(NFi(1,1)>0)
        DAn(i,:)=NFi;
    end;
    

%% 
    j=find(DAn(i,10:h)~=-1); % нашли все не * в NFi
    j=j+9;  

    if h_l==1 % hl - положение номера нефиксированого входа в последовательности описания блока
    	hl=4;
    else
    	hl=2;
    end

    for m=1:length(an) % поиск в цикле подходящей последовательности для замены
        if(D(m,j)==DAn(i,j))  % сравнение нужных элементов выходных последовательностей (не *)
            if m~=i
                k=m; % запоминание подходящей
                if an_(find(an==DAn(k,1)))<=an_(find(an==DAn(i,1))) % проверка ярусности
                    g=find(DAn(:,hl)==DAn(i,1)); % определение строки в матрице, где лежит наш рассматриваемый блок
                    DAn(g,hl)=DAn(k,1); % замена в матрице и рассматривыаемом блоке входа на подходящий
                    An(hl)=DAn(k,1);
                    break % принудительный выход вовне, не нужно искать другую замену
                end
            end
        else
        % аналогично проверяем для инвертированной последовательности
        A=D(m,:);
        A=Inve(A);
        D(m,:)=A;
        if(D(m,j)==DAn(i,j)) 
            if m~=i
                k=m;
                if an_(find(an==DAn(k,1)))<=an_(find(an==DAn(i,1)))
                    g=find(DAn(:,hl)==DAn(i,1));
                    DAn(g,hl)=DAn(k,1);
                    An(hl)=DAn(k,1);
                    DAn(g,hl+1)=0;
                    An(hl+1)=0;                    
                    break
                end
            end
        end
        % возвращаем обратно
        A= D(m,:);
        A=Inve(A);
        D(m,:)=A;
        end
    end
       
%% вызов рекурсии:
    i=find(D(:,1)==An(hl));
    An=DAn(i,:); %An включает в себя звездочки
    D=DAn; % D тоже
    D=ReOpt(D, An, an, an_, 1); %фиксируется старший вход
    D=ReOpt(D, An, an, an_, 0); %фиксируется младший вход
    
end

end

