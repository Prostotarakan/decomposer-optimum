function D = optim(D)
%% на входе
% D - матрица, описывающая двухвходовые блоки
% D(i,:)=[n n1 i1 n0 i0 a0 a1 a2 a3]
% n - номер блока
% n1, n0 - номера блоков старшего и млашего входов (входные переменные х1, х2, х4, ... отмечаются как -1 -2 -4...)
% i1, i0 - инверсность входов. 1 - неинверт. 0 - инверт
% a0 a1 a2 a3 - комбинация логической функции двухвходового блока
% Пример:
% D=[ 5 1 1 4 1 0 0 0 1;    4 2 1 3 1 0 0 0 1;    3 -8 1 -4 1 0 0 0 1;    2 -8 1 -4 1 0 0 0 1;    1 -2 1 -1 1 0 0 0 1];
%% на выходе
% D - матрица после оптимизации
%% 
% заполнение таблицы истинности
[D,an, an_]=Itable(D);
% функция возвращает D c выходными последовательностями f, порядок блоков an и их ярусы an_

[s h]=size(D); % размеры итоговой матрицы
DAn=D; % запоминаем матрицу до оптимизации
An=D(find(D(:,1)==an(find(an_==max(an_)))),:); 
% выбор последнего блока (блок максимального яруса) для дальнейшей процедуры оптимизации

% вызов функции поиска оптимизации с фиксированием старшего и младшего входов
D=ReOpt(D, An, an, an_, 1);
D=ReOpt(D, An, an, an_, 0);
% возвращает D с '*'

% проверка
[D11,~]=Itable(D);
% если итоговые выходные последовательности сошлись, то вывод матрицы D после сокращения лишних блоков
if DAn(find(DAn(:,1)==an(find(an_==max(an_)))),10:h)==D11(find(D11(:,1)==an(find(an_==max(an_)))),10:h)
    % вызов функции для сокращения всего подряд
    D11=Oposled(D11,an(find(an_==max(an_)))); % отправляется туда матрица и последний блок
    D=D11;
else 
    D=DAn;
end;
end

